(self.webpackChunkfeswap_docs=self.webpackChunkfeswap_docs||[]).push([[1884],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return k},kt:function(){return w}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var d=r.createContext({}),c=function(e){var n=r.useContext(d),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},k=function(e){var n=c(e.components);return r.createElement(d.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,d=e.parentName,k=s(e,["components","mdxType","originalType","parentName"]),u=c(t),w=a,p=u["".concat(d,".").concat(w)]||u[w]||l[w]||o;return t?r.createElement(p,i(i({ref:n},k),{},{components:t})):r.createElement(p,i({ref:n},k))}));function w(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var d in n)hasOwnProperty.call(n,d)&&(s[d]=n[d]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8074:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return l}});var r=t(2122),a=t(9756),o=(t(7294),t(3905)),i={id:"StakingTwinRewardsFactory",title:"Contract Staking Reward Factory",hide_title:!0,sidebar_label:"Staking Reward Factory",hide_table_of_contents:!0},s=void 0,d={unversionedId:"Contracts/StakingTwinRewardsFactory",id:"Contracts/StakingTwinRewardsFactory",isDocsHomePage:!1,title:"Contract Staking Reward Factory",description:"Staking Reward Factory Contact",source:"@site/docs/Contracts/StakingTwinRewardsFactory.md",sourceDirName:"Contracts",slug:"/Contracts/StakingTwinRewardsFactory",permalink:"/docs/Contracts/StakingTwinRewardsFactory",version:"current",frontMatter:{id:"StakingTwinRewardsFactory",title:"Contract Staking Reward Factory",hide_title:!0,sidebar_label:"Staking Reward Factory",hide_table_of_contents:!0},sidebar:"FeSwapSidebar",previous:{title:"Sponsor",permalink:"/docs/Contracts/sponsor"},next:{title:"Staking Reward",permalink:"/docs/Contracts/StakingTwinRewards"}},c=[{value:'<span className="title"> Staking Reward Contract Address </span>',id:"staking-reward-contract-address",children:[]},{value:'<span className="title"> Staking Reward Contract Code </span>',id:"staking-reward-contract-code",children:[]}],k={toc:c};function l(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},k,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"title"},(0,o.kt)("h1",null," Staking Reward Factory Contact ")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"FeSwap staking reward factory contact is used to distribute reward FESW tokens to the staking reward contracts."),(0,o.kt)("h3",{id:"staking-reward-contract-address"},(0,o.kt)("span",{className:"title"}," Staking Reward Contract Address ")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"ETH NetWork"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Staking Reward Factory Contract Address"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Mainnet"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://etherscan.io/address/0x9f35c6e6bb19a4cd7b1527cbceb7d70be1021675"},"0x9f35C6E6bb19A4cd7b1527CbCEB7d70be1021675"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Ropsten"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://ropsten.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Rinkeby"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://rinkeby.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Goerli"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://goerli.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Kovan"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://kovan.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))))),(0,o.kt)("h3",{id:"staking-reward-contract-code"},(0,o.kt)("span",{className:"title"}," Staking Reward Contract Code ")),(0,o.kt)("p",null,"The open-source FeSwap ",(0,o.kt)("inlineCode",{parentName:"p"},"StakingTwinRewardsFactory")," contact is stored at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/FeSwap/Governance/blob/main/contracts/StakingTwinRewardsFactory.sol"},"Github Governance Project")," "),(0,o.kt)("p",null,"Following is the code deployed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol",metastring:'title="StakingTwinRewardsFactory.sol"',title:'"StakingTwinRewardsFactory.sol"'},"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport \"./StakingTwinRewards.sol\";\n\ninterface IFeSwapPair {\n    function tokenIn() external view returns (address);\n    function tokenOut() external view returns (address);\n}\n\ncontract StakingTwinRewardsFactory is Ownable {\n    // immutables\n    address public rewardsToken;\n    uint    public stakingRewardsGenesis;\n\n    // the staking tokens for which the rewards contract has been deployed\n    address[] public stakingTokens;\n\n    // info about rewards for a particular staking token\n    struct StakingRewardsInfo {\n        address stakingTwinToken;\n        address stakingRewards;\n        uint    rewardAmount;\n        uint    rewardsDuration;\n    }\n\n    // rewards info by staking token\n    mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n    constructor(\n        address _rewardsToken,\n        uint    _stakingRewardsGenesis\n    ) Ownable() {\n        require(_stakingRewardsGenesis >= block.timestamp, 'StakingRewardsFactory::constructor: genesis too soon');\n\n        rewardsToken = _rewardsToken;\n        stakingRewardsGenesis = _stakingRewardsGenesis;\n    }\n\n    ///// permissioned functions\n\n    // deploy a staking reward contract for the staking token, and store the reward amount\n    // the reward will be distributed to the staking reward contract no sooner than the genesis\n    function deploy(address stakingTokenA, address stakingTokenB, uint rewardAmount, uint rewardsDuration) public onlyOwner {\n        require(stakingTokenA < stakingTokenB, \"Wrong token order\");\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingTokenA];\n        if(info.stakingRewards == address(0)) {\n            require(IFeSwapPair(stakingTokenA).tokenIn() == IFeSwapPair(stakingTokenB).tokenOut(), \"Wrong pair token\");\n            require(IFeSwapPair(stakingTokenA).tokenOut() == IFeSwapPair(stakingTokenB).tokenIn(), \"Wrong pair token\");\n\n            info.stakingRewards = address(new StakingTwinRewards(/*_rewardsDistribution=*/ address(this), \n                                                                rewardsToken, stakingTokenA, stakingTokenB));\n            info.stakingTwinToken = stakingTokenB;\n            info.rewardAmount = rewardAmount;\n            info.rewardsDuration = rewardsDuration;\n            stakingTokens.push(stakingTokenA);\n        } else {\n            require(info.rewardAmount == 0, 'StakingRewardsFactory::deploy: already deployed');\n            require(stakingTokenB == info.stakingTwinToken, \"Wrong twin token\");\n            info.rewardAmount = rewardAmount;                   // refill the reward contract\n            info.rewardsDuration = rewardsDuration;\n        }\n\n    }\n\n    ///// permissionless functions\n\n    // call notifyRewardAmount for all staking tokens.\n    function notifyRewardAmounts() public {\n        require(stakingTokens.length > 0, 'StakingRewardsFactory::notifyRewardAmounts: called before any deploys');\n        for (uint i = 0; i < stakingTokens.length; i++) {\n            notifyRewardAmount(stakingTokens[i]);\n        }\n    }\n\n    // notify reward amount for an individual staking token.\n    // this is a fallback in case the notifyRewardAmounts costs too much gas to call for all contracts\n    function notifyRewardAmount(address stakingToken) public {\n        require(block.timestamp >= stakingRewardsGenesis, 'StakingRewardsFactory::notifyRewardAmount: not ready');\n\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\n        require(info.stakingRewards != address(0), 'StakingRewardsFactory::notifyRewardAmount: not deployed');\n\n        if (info.rewardAmount > 0) {\n            uint rewardAmount = info.rewardAmount;\n            info.rewardAmount = 0;\n\n            require(\n                IERC20(rewardsToken).transfer(info.stakingRewards, rewardAmount),\n                'StakingRewardsFactory::notifyRewardAmount: transfer failed'\n            );\n            StakingTwinRewards(info.stakingRewards).notifyRewardAmount(rewardAmount, info.rewardsDuration);\n        }\n    }\n}\n")))}l.isMDXComponent=!0}}]);