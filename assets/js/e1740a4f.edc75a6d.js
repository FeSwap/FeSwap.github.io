(self.webpackChunkfeswap_docs=self.webpackChunkfeswap_docs||[]).push([[6726],{3905:function(e,n,a){"use strict";a.d(n,{Zo:function(){return m},kt:function(){return T}});var t=a(7294);function r(e,n,a){return n in e?Object.defineProperty(e,n,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[n]=a,e}function i(e,n){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),a.push.apply(a,t)}return a}function o(e){for(var n=1;n<arguments.length;n++){var a=null!=arguments[n]?arguments[n]:{};n%2?i(Object(a),!0).forEach((function(n){r(e,n,a[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(a,n))}))}return e}function u(e,n){if(null==e)return{};var a,t,r=function(e,n){if(null==e)return{};var a,t,r={},i=Object.keys(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||(r[a]=e[a]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)a=i[t],n.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=t.createContext({}),d=function(e){var n=t.useContext(s),a=n;return e&&(a="function"==typeof e?e(n):o(o({},n),e)),a},m=function(e){var n=d(e.components);return t.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},l=t.forwardRef((function(e,n){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),l=d(a),T=r,c=l["".concat(s,".").concat(T)]||l[T]||p[T]||i;return a?t.createElement(c,o(o({ref:n},m),{},{components:a})):t.createElement(c,o({ref:n},m))}));function T(e,n){var a=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=a.length,o=new Array(i);o[0]=l;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u.mdxType="string"==typeof e?e:r,o[1]=u;for(var d=2;d<i;d++)o[d]=a[d];return t.createElement.apply(null,o)}return t.createElement.apply(null,a)}l.displayName="MDXCreateElement"},5296:function(e,n,a){"use strict";a.r(n),a.d(n,{frontMatter:function(){return o},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return d},default:function(){return p}});var t=a(2122),r=a(9756),i=(a(7294),a(3905)),o={id:"router",title:"Contract Roter",hide_title:!0,sidebar_label:"Router",hide_table_of_contents:!0},u=void 0,s={unversionedId:"Contracts/router",id:"Contracts/router",isDocsHomePage:!1,title:"Contract Roter",description:"FeSwap Router Contract",source:"@site/docs/Contracts/Router.mdx",sourceDirName:"Contracts",slug:"/Contracts/router",permalink:"/docs/Contracts/router",version:"current",frontMatter:{id:"router",title:"Contract Roter",hide_title:!0,sidebar_label:"Router",hide_table_of_contents:!0},sidebar:"FeSwapSidebar",previous:{title:"Factory",permalink:"/docs/Contracts/factory"},next:{title:"Token Pair NFT",permalink:"/docs/Contracts/nft"}},d=[{value:'<span className="title"> Deploy Address </span>',id:"deploy-address",children:[]},{value:'<span className="title"> FeSwapRouter Code </span>',id:"feswaprouter-code",children:[]}],m={toc:d};function p(e){var n=e.components,a=(0,r.Z)(e,["components"]);return(0,i.kt)("wrapper",(0,t.Z)({},m,a,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("div",{className:"title"},(0,i.kt)("h1",null," FeSwap Router Contract ")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"FeSwap Router is the contract that users mostly interact with, which provides the user interface of liquidity-adding , liquidity-removing and token-swapping. "),(0,i.kt)("h3",{id:"deploy-address"},(0,i.kt)("span",{className:"title"}," Deploy Address ")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"center"},"ETH NetWork"),(0,i.kt)("th",{parentName:"tr",align:"center"},"Contract Address"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"ETH Mainnet"),(0,i.kt)("td",{parentName:"tr",align:"center"},"Waiting")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Ropsten"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://ropsten.etherscan.io/address/0x657db4e8c4258570cc7dd61031777901439e8079"},"0x657db4e8c4258570cc7dd61031777901439e8079"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Rinkeby"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://rinkeby.etherscan.io/address/0x657db4e8c4258570cc7dd61031777901439e8079"},"0x657db4e8c4258570cc7dd61031777901439e8079"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Goerli"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://goerli.etherscan.io/address/0x657db4e8c4258570cc7dd61031777901439e8079"},"0x657db4e8c4258570cc7dd61031777901439e8079"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Kovan"),(0,i.kt)("td",{parentName:"tr",align:"center"},(0,i.kt)("a",{parentName:"td",href:"https://kovan.etherscan.io/address/0x657db4e8c4258570cc7dd61031777901439e8079"},"0x657db4e8c4258570cc7dd61031777901439e8079"))))),(0,i.kt)("h3",{id:"feswaprouter-code"},(0,i.kt)("span",{className:"title"}," FeSwapRouter Code ")),(0,i.kt)("p",null,"The open-source FeSwap ",(0,i.kt)("inlineCode",{parentName:"p"},"Router")," contact is stored at ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/FeSwap/FeSwapCore/blob/master/contracts/FeSwapRouter.sol"},"Github FeSwapCore Project")," "),(0,i.kt)("p",null,"Following is the code deployed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sol",metastring:'title="FeSwapRouter.sol"',title:'"FeSwapRouter.sol"'},"// SPDX-License-Identifier: GPL-3.0\npragma solidity =0.6.12;\npragma experimental ABIEncoderV2;\n\nimport './interfaces/IFeSwapFactory.sol';\nimport './libraries/TransferHelper.sol';\n\nimport './interfaces/IFeSwapRouter.sol';\nimport './libraries/FeSwapLibrary.sol';\nimport './libraries/SafeMath.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IWETH.sol';\nimport './interfaces/IFeswaNFT.sol';\n\ncontract FeSwapRouter is IFeSwapRouter{\n    using SafeMath for uint;\n\n    address public immutable override factory;\n    address public immutable override feswaNFT;\n    address public immutable override WETH;\n\n    modifier ensure(uint deadline) {\n        require(deadline >= block.timestamp, 'FeSwapRouter: EXPIRED');\n        _;\n    }\n\n    constructor(address _factory, address _feswaNFT, address _WETH) public {\n        factory = _factory;\n        feswaNFT = _feswaNFT;\n        WETH = _WETH;\n    }\n\n    receive() external payable {\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\n    }\n\n    // **** CREATE SWAP PAIR ****\n    function ManageFeswaPair( uint256 tokenID, address pairOwner, uint256 rateTrigger ) \n                external virtual override \n                returns (address pairAAB, address pairABB) \n    {\n        (address nftOwner, FeswaPair memory NftBidInfo) = IFeswaNFT(feswaNFT).getPoolInfo(tokenID);\n        require(msg.sender == nftOwner, 'FeSwap: NOT TOKEN OWNER');\n        require(NftBidInfo.poolState >= PoolRunningPhase.BidSettled, 'FeSwap: NOT ALLOWED');\n        (address tokenA, address tokenB) = (NftBidInfo.tokenA, NftBidInfo.tokenB);\n        (pairAAB, pairABB) = IFeSwapFactory(factory).createUpdatePair(tokenA, tokenB, pairOwner, rateTrigger); \n    }\n\n    // **** ADD LIQUIDITY ****\n    function _addLiquidity( address tokenIn, \n                            address tokenOut, \n                            uint amountInDesired, \n                            uint amountOutDesired,\n                            uint amountInMin,\n                            uint amountOutMin \n    ) internal virtual view returns (uint amountIn, uint amountOut, address pair) {\n        pair = IFeSwapFactory(factory).getPair(tokenIn, tokenOut);\n        require(pair != address(0), 'FeSwap: NOT CREATED');\n        (uint reserveIn, uint reserveOut, ,) = IFeSwapPair(pair).getReserves();\n        if (reserveIn == 0 && reserveOut == 0) {\n            (amountIn, amountOut) = (amountInDesired, amountOutDesired);\n        } else {\n            uint amountOutOptimal = FeSwapLibrary.quote(amountInDesired, reserveIn, reserveOut);\n            if (amountOutOptimal <= amountOutDesired) {\n                require(amountOutOptimal >= amountOutMin, 'FeSwap: LESS_OUT_AMOUNT');\n                (amountIn, amountOut) = (amountInDesired, amountOutOptimal);\n            } else {\n                uint amountInOptimal = FeSwapLibrary.quote(amountOutDesired, reserveOut, reserveIn);\n                assert(amountInOptimal <= amountInDesired);\n                require(amountInOptimal >= amountInMin, 'FeSwap: LESS_IN_AMOUNT');\n                (amountIn, amountOut) = (amountInOptimal, amountOutDesired);\n            }\n        }\n    }\n\n    function addLiquidity(  AddLiquidityParams calldata addParams, \n                            address to, \n                            uint deadline ) \n                external virtual override ensure(deadline) \n                returns (uint amountA, uint amountB, uint liquidityAAB, uint liquidityABB)\n    {\n        require(addParams.ratio <= 100,  'FeSwap: RATIO EER');\n        if(addParams.ratio != uint(0)) {\n            address pairA2B;\n            uint liquidityA = addParams.amountADesired.mul(addParams.ratio)/100; \n            uint liquidityB = addParams.amountBDesired.mul(addParams.ratio)/100;\n            uint amountAMin = addParams.amountAMin.mul(addParams.ratio)/100; \n            uint amountBMin = addParams.amountBMin.mul(addParams.ratio)/100;\n            (amountA, amountB, pairA2B) = \n                            _addLiquidity(addParams.tokenA, addParams.tokenB, liquidityA, liquidityB, amountAMin, amountBMin);\n            TransferHelper.safeTransferFrom(addParams.tokenA, msg.sender, pairA2B, amountA);\n            TransferHelper.safeTransferFrom(addParams.tokenB, msg.sender, pairA2B, amountB);\n            liquidityAAB = IFeSwapPair(pairA2B).mint(to);\n        }\n        if(addParams.ratio != uint(100)) {\n            address pairB2A; \n            uint liquidityA = addParams.amountADesired - amountA; \n            uint liquidityB = addParams.amountBDesired - amountB;\n            uint amountAMin = (addParams.amountAMin != 0) ? (addParams.amountAMin - amountA) : 0 ; \n            uint amountBMin = (addParams.amountBMin != 0) ? (addParams.amountBMin - amountB) : 0 ;\n            (liquidityB, liquidityA, pairB2A) = \n                        _addLiquidity(addParams.tokenB, addParams.tokenA, liquidityB, liquidityA, amountBMin, amountAMin);\n            TransferHelper.safeTransferFrom(addParams.tokenA, msg.sender, pairB2A, liquidityA);\n            TransferHelper.safeTransferFrom(addParams.tokenB, msg.sender, pairB2A, liquidityB);\n            liquidityABB = IFeSwapPair(pairB2A).mint(to);\n            amountA += liquidityA;\n            amountB += liquidityB;\n        }\n    }\n\n    function addLiquidityETH(   AddLiquidityETHParams calldata addParams,\n                                address to,\n                                uint deadline\n    )   external virtual override payable ensure(deadline) \n        returns (uint amountToken, uint amountETH, uint liquidityTTE, uint liquidityTEE) \n    {\n        require(addParams.ratio <= 100,  'FeSwap: RATIO EER');\n        if(addParams.ratio != uint(0)) {        \n            address pairTTE;\n            uint liquidityToken = addParams.amountTokenDesired.mul(addParams.ratio)/100; \n            uint liquidityETH   = msg.value.mul(addParams.ratio)/100;\n            uint amountTokenMin = addParams.amountTokenMin.mul(addParams.ratio)/100; \n            uint amountETHMin   = addParams.amountETHMin.mul(addParams.ratio)/100;\n            (amountToken, amountETH, pairTTE) =\n                        _addLiquidity(addParams.token, WETH, liquidityToken, liquidityETH, amountTokenMin, amountETHMin);\n            TransferHelper.safeTransferFrom(addParams.token, msg.sender, pairTTE, amountToken);\n            IWETH(WETH).deposit{value: amountETH}();\n            assert(IWETH(WETH).transfer(pairTTE, amountETH));\n            liquidityTTE = IFeSwapPair(pairTTE).mint(to);\n        }\n        if(addParams.ratio != uint(100)){\n            address pairTEE;\n            uint liquidityToken = addParams.amountTokenDesired - amountToken; \n            uint liquidityETH   = msg.value - amountETH;\n            uint amountTokenMin = (addParams.amountTokenMin !=0) ? (addParams.amountTokenMin - amountToken) : 0 ;\n            uint amountETHMin   = (addParams.amountETHMin != 0) ? (addParams.amountETHMin - amountETH) : 0 ;\n            (liquidityETH, liquidityToken, pairTEE) = \n                    _addLiquidity(WETH, addParams.token, liquidityETH,  liquidityToken, amountETHMin, amountTokenMin);\n            TransferHelper.safeTransferFrom(addParams.token, msg.sender, pairTEE, liquidityToken);\n            IWETH(WETH).deposit{value: liquidityETH}();\n            assert(IWETH(WETH).transfer(pairTEE, liquidityETH));\n            liquidityTEE = IFeSwapPair(pairTEE).mint(to);     \n            amountToken += liquidityToken;\n            amountETH   += liquidityETH;       \n        }\n\n        // refund dust eth, if any\n        if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);\n    }\n\n    // **** REMOVE LIQUIDITY ****\n    function removeLiquidity(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountA, uint amountB) {\n        if(removeParams.liquidityAAB != uint(0)) {\n            address pairAAB = FeSwapLibrary.pairFor(factory, removeParams.tokenA, removeParams.tokenB);\n            IFeSwapPair(pairAAB).transferFrom(msg.sender, pairAAB, removeParams.liquidityAAB);  // send liquidity to pair\n            (amountA, amountB) = IFeSwapPair(pairAAB).burn(to);\n        }\n        if(removeParams.liquidityABB != uint(0)) {\n            address pairABB = FeSwapLibrary.pairFor(factory, removeParams.tokenB, removeParams.tokenA);\n            IFeSwapPair(pairABB).transferFrom(msg.sender, pairABB, removeParams.liquidityABB);  // send liquidity to pair\n            (uint amountB0, uint amountA0) = IFeSwapPair(pairABB).burn(to);\n            amountA += amountA0;\n            amountB += amountB0;\n        }\n        require(amountA >= removeParams.amountAMin, 'FeSwapRouter: INSUFFICIENT_A_AMOUNT');\n        require(amountB >= removeParams.amountBMin, 'FeSwapRouter: INSUFFICIENT_B_AMOUNT');\n    }\n\n    function removeLiquidityETH(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountToken, uint amountETH) {\n        require(removeParams.tokenB == WETH,  'FeSwap: WRONG WETH');\n        (amountToken, amountETH) = removeLiquidity(\n            removeParams,    \n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(removeParams.tokenA, to, amountToken);\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removePermit(\n        RemoveLiquidityParams calldata removeParams,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigAAB,\n        Signature   calldata sigABB\n    ) internal {\n        if(sigAAB.r != 0){\n            address pairAAB = FeSwapLibrary.pairFor(factory, removeParams.tokenA, removeParams.tokenB);\n            uint value = approveMax ? uint(-1) : removeParams.liquidityAAB; \n            IFeSwapPair(pairAAB).permit(msg.sender, address(this), value, deadline, sigAAB.v, sigAAB.r, sigAAB.s);\n        }\n        if(sigABB.r != 0){\n            address pairABB = FeSwapLibrary.pairFor(factory, removeParams.tokenB, removeParams.tokenA);\n            uint value = approveMax ? uint(-1) : removeParams.liquidityABB; \n            IFeSwapPair(pairABB).permit(msg.sender, address(this), value, deadline, sigABB.v, sigABB.r, sigABB.s);\n        }    \n    }\n\n    function removeLiquidityWithPermit(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigAAB,\n        Signature   calldata sigABB\n    ) external virtual override returns (uint amountA, uint amountB) {\n        removePermit(removeParams, deadline, approveMax, sigAAB, sigABB);\n        (amountA, amountB) = removeLiquidity(removeParams, to, deadline);\n    }\n\n    function removeLiquidityETHWithPermit(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigTTE,\n        Signature   calldata sigTEE\n    ) external virtual override returns (uint amountToken, uint amountETH) {\n        require(removeParams.tokenB == WETH,  'FeSwap: WRONG WETH');\n        removePermit(removeParams, deadline, approveMax, sigTTE, sigTEE);\n        (amountToken, amountETH) = removeLiquidityETH(removeParams, to, deadline);\n    }\n\n    // **** REMOVE LIQUIDITY (supporting deflation tokens) ****\n    function removeLiquidityETHFeeOnTransfer(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) public virtual override ensure(deadline) returns (uint amountETH) {\n        require(removeParams.tokenB == WETH,  'FeSwap: WRONG WETH');\n        ( , amountETH) = removeLiquidity(\n            removeParams,    \n            address(this),\n            deadline\n        );\n        TransferHelper.safeTransfer(removeParams.tokenA, to, IERC20(removeParams.tokenA).balanceOf(address(this)));\n        IWETH(WETH).withdraw(amountETH);\n        TransferHelper.safeTransferETH(to, amountETH);\n    }\n\n    function removeLiquidityETHWithPermitFeeOnTransfer(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigTTE,\n        Signature   calldata sigTEE\n    ) external virtual override returns (uint amountETH) {\n        require(removeParams.tokenB == WETH,  'FeSwap: WRONG WETH');\n        removePermit(removeParams, deadline, approveMax, sigTTE, sigTEE);\n        amountETH = removeLiquidityETHFeeOnTransfer(removeParams, to, deadline);\n    }\n\n    // **** SWAP ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swap(uint[] memory amounts, address[] memory path, address _to) internal virtual {\n        for (uint i = 0; i < path.length - 1; i++) {\n            (address tokenInput, address tokenOutput) = (path[i], path[i + 1]);\n            uint amountOut = amounts[i + 1];\n            address to = i < path.length - 2 ? FeSwapLibrary.pairFor(factory, tokenOutput, path[i + 2]) : _to;\n            IFeSwapPair(FeSwapLibrary.pairFor(factory, tokenInput, tokenOutput))\n                .swap(amountOut, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        address firstPair;\n        (firstPair, amounts) = FeSwapLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, firstPair , amounts[0]);\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) returns (uint[] memory amounts) {\n        address firstPair;\n        (firstPair, amounts) = FeSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'FeSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, firstPair, amounts[0]);\n        _swap(amounts, path, to);\n    }\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external virtual override payable ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'FeSwapRouter: INVALID_PATH');\n        address _firstPair;\n        (_firstPair, amounts) = FeSwapLibrary.getAmountsOut(factory, msg.value, path);            // to save 536 gas\n        require(amounts[amounts.length - 1] >= amountOutMin, 'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(_firstPair, amounts[0]));\n        _swap(amounts, path, to);\n    }\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external virtual override ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'FeSwapRouter: INVALID_PATH');\n        address _firstPair;\n        (_firstPair, amounts) = FeSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= amountInMax, 'FeSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, _firstPair, amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external virtual override ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[path.length - 1] == WETH, 'FeSwapRouter: INVALID_PATH');\n        address _firstPair;\n        (_firstPair, amounts) = FeSwapLibrary.getAmountsOut(factory, amountIn, path);\n        require(amounts[amounts.length - 1] >= amountOutMin, 'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        TransferHelper.safeTransferFrom(path[0], msg.sender, _firstPair, amounts[0]);\n        _swap(amounts, path, address(this));\n        IWETH(WETH).withdraw(amounts[amounts.length - 1]);\n        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);\n    }\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external virtual override payable ensure(deadline)\n        returns (uint[] memory amounts)\n    {\n        require(path[0] == WETH, 'FeSwapRouter: INVALID_PATH');\n        address _firstPair;\n        (_firstPair, amounts) = FeSwapLibrary.getAmountsIn(factory, amountOut, path);\n        require(amounts[0] <= msg.value, 'FeSwapRouter: EXCESSIVE_INPUT_AMOUNT');\n        IWETH(WETH).deposit{value: amounts[0]}();\n        assert(IWETH(WETH).transfer(_firstPair, amounts[0]));\n        _swap(amounts, path, to);\n        // refund dust eth, if any\n        if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);\n    }\n\n    // **** SWAP (supporting fee-on-transfer tokens) ****\n    // requires the initial amount to have already been sent to the first pair\n    function _swapTokensFeeOnTransfer(address[] memory path, address _to) internal virtual {\n        for (uint i = 0; i < path.length - 1; i++) {\n            (address input, address output) = (path[i], path[i + 1]);\n            (uint reserveInput, uint reserveOutput, address pair, ) = FeSwapLibrary.getReserves(factory, input, output);\n            uint amountInput = IERC20(input).balanceOf(pair).sub(reserveInput);\n            uint amountOutput = FeSwapLibrary.getAmountOut(amountInput, reserveInput, reserveOutput);\n            address to = i < path.length - 2 ? FeSwapLibrary.pairFor(factory, output, path[i + 2]) : _to;\n            IFeSwapPair(pair).swap(amountOutput, to, new bytes(0));\n        }\n    }\n\n    function swapExactTokensForTokensFeeOnTransfer(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        FeSwapLibrary.executeArbitrage(factory, path);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, FeSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapTokensFeeOnTransfer(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactETHForTokensFeeOnTransfer(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override payable ensure(deadline) {\n        require(path[0] == WETH, 'FeSwapRouter: INVALID_PATH');\n        FeSwapLibrary.executeArbitrage(factory, path);\n        uint amountIn = msg.value;\n        IWETH(WETH).deposit{value: amountIn}();\n        assert(IWETH(WETH).transfer(FeSwapLibrary.pairFor(factory, path[0], path[1]), amountIn));\n        uint balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);\n        _swapTokensFeeOnTransfer(path, to);\n        require(\n            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,\n            'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT'\n        );\n    }\n    function swapExactTokensForETHFeeOnTransfer(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external virtual override ensure(deadline) {\n        require(path[path.length - 1] == WETH, 'FeSwapRouter: INVALID_PATH');\n        FeSwapLibrary.executeArbitrage(factory, path);\n        TransferHelper.safeTransferFrom(\n            path[0], msg.sender, FeSwapLibrary.pairFor(factory, path[0], path[1]), amountIn\n        );\n        _swapTokensFeeOnTransfer(path, address(this));\n        uint amountOut = IERC20(WETH).balanceOf(address(this));\n        require(amountOut >= amountOutMin, 'FeSwapRouter: INSUFFICIENT_OUTPUT_AMOUNT');\n        IWETH(WETH).withdraw(amountOut);\n        TransferHelper.safeTransferETH(to, amountOut);\n    }\n\n    // **** LIBRARY FUNCTIONS ****\n    function quote(uint amountA, uint reserveA, uint reserveB) \n                public pure virtual override returns (uint amountB) \n    {\n        return FeSwapLibrary.quote(amountA, reserveA, reserveB);\n    }\n\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut)\n                public view virtual override returns (uint amountOut)\n    {\n        return FeSwapLibrary.getAmountOut(amountIn, reserveIn, reserveOut);\n    }\n\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut)\n                public view virtual override returns (uint amountIn)\n    {\n        return FeSwapLibrary.getAmountIn(amountOut, reserveIn, reserveOut);\n    }\n\n    function estimateAmountsOut(uint amountIn, address[] calldata path)\n                public view virtual override returns (uint[] memory amounts)\n    {\n        return FeSwapLibrary.estimateAmountsOut(factory, amountIn, path);\n    }\n\n    function estimateAmountsIn(uint amountOut, address[] calldata path)\n                public view virtual override returns (uint[] memory amounts)\n    {\n        return FeSwapLibrary.estimateAmountsIn(factory, amountOut, path);\n    }\n}\n")))}p.isMDXComponent=!0}}]);