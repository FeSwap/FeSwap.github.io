(self.webpackChunkfeswap_docs=self.webpackChunkfeswap_docs||[]).push([[1884],{3905:function(n,e,t){"use strict";t.d(e,{Zo:function(){return k},kt:function(){return w}});var r=t(7294);function a(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function o(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?o(Object(t),!0).forEach((function(e){a(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function s(n,e){if(null==n)return{};var t,r,a=function(n,e){if(null==n)return{};var t,r,a={},o=Object.keys(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||(a[t]=n[t]);return a}(n,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);for(r=0;r<o.length;r++)t=o[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(a[t]=n[t])}return a}var d=r.createContext({}),c=function(n){var e=r.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):i(i({},e),n)),t},k=function(n){var e=c(n.components);return r.createElement(d.Provider,{value:e},n.children)},l={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},u=r.forwardRef((function(n,e){var t=n.components,a=n.mdxType,o=n.originalType,d=n.parentName,k=s(n,["components","mdxType","originalType","parentName"]),u=c(t),w=a,p=u["".concat(d,".").concat(w)]||u[w]||l[w]||o;return t?r.createElement(p,i(i({ref:e},k),{},{components:t})):r.createElement(p,i({ref:e},k))}));function w(n,e){var t=arguments,a=e&&e.mdxType;if("string"==typeof n||a){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var d in e)hasOwnProperty.call(e,d)&&(s[d]=e[d]);s.originalType=n,s.mdxType="string"==typeof n?n:a,i[1]=s;for(var c=2;c<o;c++)i[c]=t[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},8074:function(n,e,t){"use strict";t.r(e),t.d(e,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return d},toc:function(){return c},default:function(){return l}});var r=t(2122),a=t(9756),o=(t(7294),t(3905)),i={id:"StakingTwinRewardsFactory",title:"Contract Staking Reward Factory",hide_title:!0,sidebar_label:"Staking Reward Factory",hide_table_of_contents:!0},s=void 0,d={unversionedId:"Contracts/StakingTwinRewardsFactory",id:"Contracts/StakingTwinRewardsFactory",isDocsHomePage:!1,title:"Contract Staking Reward Factory",description:"Staking Reward Factory Contact",source:"@site/docs/Contracts/StakingTwinRewardsFactory.md",sourceDirName:"Contracts",slug:"/Contracts/StakingTwinRewardsFactory",permalink:"/cn/docs/Contracts/StakingTwinRewardsFactory",version:"current",frontMatter:{id:"StakingTwinRewardsFactory",title:"Contract Staking Reward Factory",hide_title:!0,sidebar_label:"Staking Reward Factory",hide_table_of_contents:!0},sidebar:"FeSwapSidebar",previous:{title:"Sponsor",permalink:"/cn/docs/Contracts/sponsor"},next:{title:"Staking Reward",permalink:"/cn/docs/Contracts/StakingTwinRewards"}},c=[{value:'<span className="title"> Staking Reward Contract Address </span>',id:"staking-reward-contract-address",children:[]},{value:'<span className="title"> Staking Reward Contract Code </span>',id:"staking-reward-contract-code",children:[]}],k={toc:c};function l(n){var e=n.components,t=(0,a.Z)(n,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},k,t,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"title"},(0,o.kt)("h1",null," Staking Reward Factory Contact ")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"FeSwap staking reward factory contact is used to distribute reward FESW tokens to the staking reward contracts."),(0,o.kt)("h3",{id:"staking-reward-contract-address"},(0,o.kt)("span",{className:"title"}," Staking Reward Contract Address ")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"ETH NetWork"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Staking Reward Factory Contract Address"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Mainnet"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://etherscan.io/address/0x9f35c6e6bb19a4cd7b1527cbceb7d70be1021675"},"0x9f35C6E6bb19A4cd7b1527CbCEB7d70be1021675"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Ropsten"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://ropsten.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Rinkeby"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://rinkeby.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Goerli"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://goerli.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Kovan"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://kovan.etherscan.io/address/0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"},"0x940EA0910C2B71794e7Bc411ea6cf45091B1d1C4"))))),(0,o.kt)("h3",{id:"staking-reward-contract-code"},(0,o.kt)("span",{className:"title"}," Staking Reward Contract Code ")),(0,o.kt)("p",null,"The open-source FeSwap ",(0,o.kt)("inlineCode",{parentName:"p"},"StakingTwinRewardsFactory")," contact is stored at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/FeSwap/Governance/blob/main/contracts/StakingTwinRewardsFactory.sol"},"Github Governance Project")," "),(0,o.kt)("p",null,"Following is the code deployed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol",metastring:'title="StakingTwinRewardsFactory.sol"',title:'"StakingTwinRewardsFactory.sol"'},"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\n\nimport '@openzeppelin/contracts/access/Ownable.sol';\nimport \"./StakingTwinRewards.sol\";\n\ninterface IFeSwapPair {\n    function tokenIn() external view returns (address);\n    function tokenOut() external view returns (address);\n}\n\ncontract StakingTwinRewardsFactory is Ownable {\n    // immutables\n    address public rewardsToken;\n    uint    public stakingRewardsGenesis;\n\n    // the staking tokens for which the rewards contract has been deployed\n    address[] public stakingTokens;\n\n    // info about rewards for a particular staking token\n    struct StakingRewardsInfo {\n        address stakingTwinToken;\n        address stakingRewards;\n        uint    rewardAmount;\n        uint    rewardsDuration;\n    }\n\n    // rewards info by staking token\n    mapping(address => StakingRewardsInfo) public stakingRewardsInfoByStakingToken;\n\n    constructor(\n        address _rewardsToken,\n        uint    _stakingRewardsGenesis\n    ) Ownable() {\n        require(_stakingRewardsGenesis >= block.timestamp, 'StakingRewardsFactory::constructor: genesis too soon');\n\n        rewardsToken = _rewardsToken;\n        stakingRewardsGenesis = _stakingRewardsGenesis;\n    }\n\n    ///// permissioned functions\n\n    // deploy a staking reward contract for the staking token, and store the reward amount\n    // the reward will be distributed to the staking reward contract no sooner than the genesis\n    function deploy(address stakingTokenA, address stakingTokenB, uint rewardAmount, uint rewardsDuration) public onlyOwner {\n        require(stakingTokenA < stakingTokenB, \"Wrong token order\");\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingTokenA];\n        if(info.stakingRewards == address(0)) {\n            require(IFeSwapPair(stakingTokenA).tokenIn() == IFeSwapPair(stakingTokenB).tokenOut(), \"Wrong pair token\");\n            require(IFeSwapPair(stakingTokenA).tokenOut() == IFeSwapPair(stakingTokenB).tokenIn(), \"Wrong pair token\");\n\n            info.stakingRewards = address(new StakingTwinRewards(/*_rewardsDistribution=*/ address(this), \n                                                                rewardsToken, stakingTokenA, stakingTokenB));\n            info.stakingTwinToken = stakingTokenB;\n            info.rewardAmount = rewardAmount;\n            info.rewardsDuration = rewardsDuration;\n            stakingTokens.push(stakingTokenA);\n        } else {\n            require(info.rewardAmount == 0, 'StakingRewardsFactory::deploy: already deployed');\n            require(stakingTokenB == info.stakingTwinToken, \"Wrong twin token\");\n            info.rewardAmount = rewardAmount;                   // refill the reward contract\n            info.rewardsDuration = rewardsDuration;\n        }\n\n    }\n\n    ///// permissionless functions\n\n    // call notifyRewardAmount for all staking tokens.\n    function notifyRewardAmounts() public {\n        require(stakingTokens.length > 0, 'StakingRewardsFactory::notifyRewardAmounts: called before any deploys');\n        for (uint i = 0; i < stakingTokens.length; i++) {\n            notifyRewardAmount(stakingTokens[i]);\n        }\n    }\n\n    // notify reward amount for an individual staking token.\n    // this is a fallback in case the notifyRewardAmounts costs too much gas to call for all contracts\n    function notifyRewardAmount(address stakingToken) public {\n        require(block.timestamp >= stakingRewardsGenesis, 'StakingRewardsFactory::notifyRewardAmount: not ready');\n\n        StakingRewardsInfo storage info = stakingRewardsInfoByStakingToken[stakingToken];\n        require(info.stakingRewards != address(0), 'StakingRewardsFactory::notifyRewardAmount: not deployed');\n\n        if (info.rewardAmount > 0) {\n            uint rewardAmount = info.rewardAmount;\n            info.rewardAmount = 0;\n\n            require(\n                IERC20(rewardsToken).transfer(info.stakingRewards, rewardAmount),\n                'StakingRewardsFactory::notifyRewardAmount: transfer failed'\n            );\n            StakingTwinRewards(info.stakingRewards).notifyRewardAmount(rewardAmount, info.rewardsDuration);\n        }\n    }\n}\n")))}l.isMDXComponent=!0}}]);