(self.webpackChunkfeswap_docs=self.webpackChunkfeswap_docs||[]).push([[5841],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return l},kt:function(){return f}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},l=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=d(t),f=a,m=u["".concat(c,".").concat(f)]||u[f]||p[f]||o;return t?r.createElement(m,i(i({ref:n},l),{},{components:t})):r.createElement(m,i({ref:n},l))}));function f(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2846:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return i},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var r=t(2122),a=t(9756),o=(t(7294),t(3905)),i={id:"nft",title:"Contract Token Pair NFT",hide_title:!0,sidebar_label:"Token Pair NFT",hide_table_of_contents:!0},s=void 0,c={unversionedId:"Contracts/nft",id:"Contracts/nft",isDocsHomePage:!1,title:"Contract Token Pair NFT",description:"Token Pair NFT",source:"@site/docs/Contracts/NFT.md",sourceDirName:"Contracts",slug:"/Contracts/nft",permalink:"/cn/docs/Contracts/nft",editUrl:"https://github.com/feswap/docs/Contracts/NFT.md",version:"current",frontMatter:{id:"nft",title:"Contract Token Pair NFT",hide_title:!0,sidebar_label:"Token Pair NFT",hide_table_of_contents:!0},sidebar:"FeSwapSidebar",previous:{title:"Router",permalink:"/cn/docs/Contracts/router"},next:{title:"Sponsor",permalink:"/cn/docs/Contracts/sponsor"}},d=[{value:'<span className="title"> Token Pair NFT Contract Address </span>',id:"token-pair-nft-contract-address",children:[]},{value:'<span className="title"> Token Pair NFT Code </span>',id:"token-pair-nft-code",children:[]}],l={toc:d};function p(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"title"},(0,o.kt)("h1",null," Token Pair NFT ")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"FeSwap ",(0,o.kt)("inlineCode",{parentName:"p"},"Token Pair NFT")," contract is the contract that users could involve in the bidding for specific liquidity pool. Please refer to ",(0,o.kt)("a",{parentName:"p",href:"../FeSwap/nft"},"NFT")," for the detailed bid rules."),(0,o.kt)("p",null,"As the NFT owner, the bidding winner could control some transaction paramters of the swap pool, and share the swap profit together with FeSwap. "),(0,o.kt)("h3",{id:"token-pair-nft-contract-address"},(0,o.kt)("span",{className:"title"}," Token Pair NFT Contract Address ")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"ETH NetWork"),(0,o.kt)("th",{parentName:"tr",align:"center"},"Token Pair NFT Contract Address"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Mainnet"),(0,o.kt)("td",{parentName:"tr",align:"center"},"Waiting")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Ropsten"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://ropsten.etherscan.io/address/0x06c2de45973df34dab22ad0b767d2be3eca5d178"},"0x06c2de45973df34dab22ad0b767d2be3eca5d178"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Rinkeby"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://rinkeby.etherscan.io/address/0x06c2de45973df34dab22ad0b767d2be3eca5d178"},"0x06c2de45973df34dab22ad0b767d2be3eca5d178"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Goerli"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://goerli.etherscan.io/address/0x06c2de45973df34dab22ad0b767d2be3eca5d178"},"0x06c2de45973df34dab22ad0b767d2be3eca5d178"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Kovan"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://kovan.etherscan.io/address/0x06c2de45973df34dab22ad0b767d2be3eca5d178"},"0x06c2de45973df34dab22ad0b767d2be3eca5d178"))))),(0,o.kt)("h3",{id:"token-pair-nft-code"},(0,o.kt)("span",{className:"title"}," Token Pair NFT Code ")),(0,o.kt)("p",null,"The open-source FeSwap ",(0,o.kt)("inlineCode",{parentName:"p"},"Token Pair NFT")," contact is stored at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/FeSwap/Governance/blob/main/contracts/FeswaNFT.sol"},"Github Governance Project")," "),(0,o.kt)("p",null,"Following is the code deployed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol",metastring:'title="FeswaNFT.sol"',title:'"FeswaNFT.sol"'},"// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"./utils/TransferHelper.sol\";\n\n    enum PoolRunningPhase {\n        BidToStart,\n        BidPhase, \n        BidDelaying,\n        BidSettled,\n        PoolHolding, \n        PoolForSale\n    }\n\n    struct FeswaPair {\n        address tokenA;\n        address tokenB;\n        uint256 currentPrice;\n        uint64  timeCreated;\n        uint64  lastBidTime; \n        PoolRunningPhase  poolState;\n    }\n\n/**\n * @title FeswaNFT contract\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\n */\n\ncontract FeswaNFT is ERC721, Ownable { \n\n    using SafeMath for uint256;\n    using Address for address;\n\n    // Public variables\n    string public constant NAME = 'Feswap Pool NFT';\n    string public constant SYMBOL = 'FESN';\n\n    // Price offering duration: two weeks \n//    uint256 public constant OPEN_BID_DURATION = (3600 * 10);                    // For test\n    uint256 public constant OPEN_BID_DURATION = (3600 * 24 * 14);\n\n    // Price offering waiting duration: 2 Hours\n    uint256 public constant CLOSE_BID_DELAY = (3600 * 2);           \n\n    // Airdrop for the first tender: 1000 FESW\n    uint256 public constant AIRDROP_FOR_FIRST = 1000e18;  \n\n    // Airdrop for the next tender: 500 FESW\n    uint256 public constant AIRDROP_FOR_NEXT = 500e18;  \n\n    // Airdrop rate for Bid winner: 20000 FESW/ETH\n    uint256 public constant AIRDROP_RATE_FOR_WINNER = 20000;    \n\n    // Minimum price increase for tender: 0.1ETH\n    uint256 public constant MINIMUM_PRICE_INCREACE = 1e17;    \n\n    // Max price for NFT sale: 100,000,000ETH\n    uint256 public constant MAX_SALE_PRICE = 10_000_000e18; \n\n    // contract of Feswap DAO Token\n    address public FeswapToken;       \n\n    // Price Low Limit for pool creation:  0.2ETH\n    uint256 public PriceLowLimit;       \n\n    // Sale start timestamp\n    uint256 public SaleStartTime;                                   // 1626825600  //2021/07/21 08:00\n\n    // Mapping from token ID to token pair infomation\n    mapping (uint256 => FeswaPair) public ListPools;\n \n    // Events\n    event PairCreadted(address indexed tokenA, address indexed tokenB, uint256 tokenID);\n  \n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (address feswaToken, uint256 priceLowLimit, uint256 saleStartTime ) \n        ERC721(NAME, SYMBOL)\n    {\n        FeswapToken = feswaToken;\n        PriceLowLimit = priceLowLimit;\n        SaleStartTime = saleStartTime;\n    }\n\n    /**\n     * @dev Bid for the token-pair swap pool with higher price. \n     * Create the new token for the fisrt-time calling with minumum initial price \n     */\n    function BidFeswaPair(address tokenA, address tokenB, address to) external payable returns (uint256 tokenID) {\n        require(block.timestamp > SaleStartTime, 'FESN: BID NOT STARTED');\n        require(tokenA != tokenB, 'FESN: IDENTICAL_ADDRESSES');\n        require(msg.value >= PriceLowLimit, 'FESN: PAY LESS');\n\n        (address token0, address token1) = (tokenA <= tokenB) ? (tokenA, tokenB) : (tokenB, tokenA);\n        tokenID  = uint256(keccak256(abi.encodePacked(address(this), token0, token1)));\n\n        if(_exists(tokenID )){\n            FeswaPair storage pairInfo = ListPools[tokenID]; \n            require(msg.value >= pairInfo.currentPrice.mul(11).div(10), 'FESN: PAY LESS');  // minimum 10% increase\n            require(msg.value >= pairInfo.currentPrice.add(MINIMUM_PRICE_INCREACE), 'FESN: PAY LESS');  // minimum 10% increase\n\n            if(pairInfo.poolState == PoolRunningPhase.BidPhase){\n                require(block.timestamp <= pairInfo.timeCreated + OPEN_BID_DURATION, 'FESN: BID TOO LATE');  // Bid keep open for two weeks\n                if(block.timestamp >= (pairInfo.timeCreated + OPEN_BID_DURATION - CLOSE_BID_DELAY)) {\n                    pairInfo.poolState = PoolRunningPhase.BidDelaying;\n                }\n            } else {\n                require(pairInfo.poolState == PoolRunningPhase.BidDelaying, 'FESN: BID COMPLETED'); \n                require(block.timestamp <= pairInfo.lastBidTime + CLOSE_BID_DELAY, 'FESN: BID TOO LATE');\n            }\n\n            // update last tender timestamp\n            pairInfo.lastBidTime = uint64(block.timestamp);\n\n            // calculte repay amount\n            uint256 repayAmount = msg.value.add(pairInfo.currentPrice.mul(9)).div(10);      // B + (A-B)/10\n            address preOwner = ownerOf(tokenID);\n            \n            // Change the token owner\n            _transfer(preOwner, to, tokenID);\n            pairInfo.currentPrice = msg.value;\n\n            // Repay the previous owner with 10% of the price increasement              \n            TransferHelper.safeTransferETH(preOwner, repayAmount);\n\n            // Airdrop to the next coming tenders\n            TransferHelper.safeTransfer(FeswapToken, to, AIRDROP_FOR_NEXT);\n\n        } else {\n            // _mint will check 'to' not be Zero, and tokenID not repeated.\n            _mint(to, tokenID);\n\n            // Prepare swap token-pair infomation\n            FeswaPair memory pairInfo;\n            pairInfo.tokenA = token0;\n            pairInfo.tokenB = token1;\n            pairInfo.currentPrice = msg.value;              //could be more than PriceLowLimit\n            pairInfo.timeCreated = uint64(block.timestamp);\n            pairInfo.lastBidTime = uint64(block.timestamp);\n            pairInfo.poolState = PoolRunningPhase.BidPhase;\n\n            ListPools[tokenID] = pairInfo;\n            emit PairCreadted(tokenA, tokenB, tokenID);\n\n            // Airdrop to the first tender\n            TransferHelper.safeTransfer(FeswapToken, to, AIRDROP_FOR_FIRST);\n        }\n    }\n\n    /**\n     * @dev Settle the bid for the swap pair. \n     */\n    function FeswaPairSettle(uint256 tokenID) external {\n        require(msg.sender == ownerOf(tokenID), 'FESN: NOT TOKEN OWNER');       // ownerOf checked if tokenID existing\n        \n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        if(pairInfo.poolState == PoolRunningPhase.BidPhase){\n            require(block.timestamp > pairInfo.timeCreated + OPEN_BID_DURATION, 'FESN: BID ON GOING');  \n        } else {\n            require(pairInfo.poolState == PoolRunningPhase.BidDelaying, 'FESN: BID COMPLETED'); \n            require(block.timestamp > pairInfo.lastBidTime + CLOSE_BID_DELAY, 'FESN: BID ON GOING');\n        }\n\n        pairInfo.poolState = PoolRunningPhase.BidSettled;\n\n        // Airdrop to the first tender\n        TransferHelper.safeTransfer(FeswapToken, msg.sender, pairInfo.currentPrice.mul(AIRDROP_RATE_FOR_WINNER));\n    }    \n\n    /**\n     * @dev Sell the Pair with the specified Price. \n     */\n    function FeswaPairForSale(uint256 tokenID, uint256 pairPrice) external returns (uint256 newPrice) {\n        require(msg.sender == ownerOf(tokenID), 'FESN: NOT TOKEN OWNER');       // ownerOf checked if tokenID existing\n        \n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        require(pairInfo.poolState >= PoolRunningPhase.BidSettled, 'FESN: BID NOT SETTLED'); \n\n        if(pairPrice != 0){\n            require(pairPrice <= MAX_SALE_PRICE, 'FESN: PRICE TOO HIGH'); \n            pairInfo.poolState = PoolRunningPhase.PoolForSale;\n            pairInfo.currentPrice = pairPrice;\n        } else {\n            pairInfo.poolState = PoolRunningPhase.PoolHolding;\n        }\n        \n        return pairPrice;\n    }    \n\n    /**\n     * @dev Sell the Pair with the specified Price. \n     */\n    function FeswaPairBuyIn(uint256 tokenID, uint256 newPrice, address to) external payable returns (uint256 getPrice) {\n        require(_exists(tokenID), 'FESN: TOKEN NOT CREATED');\n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        require( pairInfo.poolState == PoolRunningPhase.PoolForSale, 'FESN: NOT FOR SALE');\n\n        uint256  currentPrice = pairInfo.currentPrice;\n        require(msg.value >= currentPrice, 'FESN: PAY LESS');  \n\n        // Change the token owner\n         address preOwner = ownerOf(tokenID);\n        _transfer(preOwner, to, tokenID);\n\n        if(newPrice != 0){\n            require(newPrice <= MAX_SALE_PRICE, 'FESN: PRICE TOO HIGH'); \n            pairInfo.currentPrice = newPrice;\n        } else {\n            pairInfo.poolState = PoolRunningPhase.PoolHolding;\n        }\n\n        // Send ETH to the owner                    \n        TransferHelper.safeTransferETH(preOwner, currentPrice);\n        if( msg.value > currentPrice) \n            TransferHelper.safeTransferETH(msg.sender, msg.value - currentPrice);\n\n        return currentPrice;    \n    }    \n\n    /**\n     * @dev Return the token-pair information \n     */\n    function getPoolInfoByTokens(address tokenA, address tokenB) external view returns (uint256 tokenID, address nftOwner, FeswaPair memory pairInfo) {\n        (address token0, address token1) = (tokenA < tokenB) ? (tokenA, tokenB) : (tokenB, tokenA);\n        tokenID = uint256(keccak256(abi.encodePacked(address(this), token0, token1)));\n        (nftOwner, pairInfo) = getPoolInfo(tokenID);\n    }\n\n    /**\n     * @dev Return the token pair addresses by TokenID \n     */\n    function getPoolInfo(uint256 tokenID) public view returns (address nftOwner, FeswaPair memory pairInfo) {\n        if(_exists(tokenID)){\n            nftOwner = ownerOf(tokenID);\n            pairInfo = ListPools[tokenID];\n        }\n    }\n\n    /**\n     * @dev Set the initial pool price\n     */\n    function setPriceLowLimit(uint256 priceLowLimit) public onlyOwner{\n        PriceLowLimit = priceLowLimit;\n    }\n\n    /**\n     * @dev Withdraw\n     */\n    function withdraw(address to, uint256 value) public onlyOwner{\n        require(address(this).balance >= value, 'FESN: INSUFFICIENT BALANCE');\n        TransferHelper.safeTransferETH(to, value);\n    }\n\n    /**\n     * @dev @dev Set the prefix for the tokenURIs.\n     */\n    function setTokenURIPrefix(string memory prefix) public onlyOwner {\n        _setBaseURI(prefix);\n    }\n}\n")))}p.isMDXComponent=!0}}]);