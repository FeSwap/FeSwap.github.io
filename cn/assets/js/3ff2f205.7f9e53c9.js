(self.webpackChunkfeswap_docs=self.webpackChunkfeswap_docs||[]).push([[5479],{3905:function(e,n,t){"use strict";t.d(n,{Zo:function(){return u},kt:function(){return p}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=d(t),p=a,f=m["".concat(c,".").concat(p)]||m[p]||l[p]||o;return t?r.createElement(f,s(s({ref:n},u),{},{components:t})):r.createElement(f,s({ref:n},u))}));function p(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var d=2;d<o;d++)s[d]=t[d];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},4:function(e,n,t){"use strict";t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return i},metadata:function(){return c},toc:function(){return d},default:function(){return l}});var r=t(2122),a=t(9756),o=(t(7294),t(3905)),s={id:"fesw",title:"FESW DAO",hide_title:!0,sidebar_label:"FESW DAO",hide_table_of_contents:!0},i=void 0,c={unversionedId:"Contracts/fesw",id:"Contracts/fesw",isDocsHomePage:!1,title:"FESW DAO",description:"FeSwap Governance Token",source:"@site/docs/Contracts/Fesw.md",sourceDirName:"Contracts",slug:"/Contracts/fesw",permalink:"/cn/docs/Contracts/fesw",editUrl:"https://github.com/feswap/docs/Contracts/Fesw.md",version:"current",frontMatter:{id:"fesw",title:"FESW DAO",hide_title:!0,sidebar_label:"FESW DAO",hide_table_of_contents:!0},sidebar:"FeSwapSidebar",previous:{title:"How to sponsor FeSwap",permalink:"/cn/docs/How/sponsor"},next:{title:"Factory",permalink:"/cn/docs/Contracts/factory"}},d=[{value:'<span className="title"> FESW Token Address </span>',id:"fesw-token-address",children:[]},{value:'<span className="title"> FESW Token Deployments Parameters </span>',id:"fesw-token-deployments-parameters",children:[]},{value:'<span className="title"> FESW Token Contract Code </span>',id:"fesw-token-contract-code",children:[]}],u={toc:d};function l(e){var n=e.components,t=(0,a.Z)(e,["components"]);return(0,o.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("div",{className:"title"},(0,o.kt)("h1",null," FeSwap Governance Token ")),(0,o.kt)("hr",null),(0,o.kt)("p",null,"FESW is the FeSwap DAO governance token, which represents the votes to FeSwap DAO governance proposals. FESW is ERC20 compliant, and provides interface to managing the voting rights. "),(0,o.kt)("p",null,"FESW total supply is 1,000,000,000 FESW, and is distributed to FeSwap community members based on their contribution to FeSwap DAO, which may include providing liquidity, conducting token exchange, sponsoring FeSwap, token-pair NFT bidding, developing, marketing, governance voting, and so on. Please refer to ",(0,o.kt)("a",{parentName:"p",href:"../FeSwap/governance"},"FeSwap Governance")," for the distribution rules."),(0,o.kt)("h3",{id:"fesw-token-address"},(0,o.kt)("span",{className:"title"}," FESW Token Address ")),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"center"},"ETH NetWork"),(0,o.kt)("th",{parentName:"tr",align:"center"},"FESW Token Address"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Mainnet"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://etherscan.io/address/0x4269eaec0710b874ea55e2AeDc8Fb66223522Bbe"},"0x4269eaec0710b874ea55e2AeDc8Fb66223522Bbe"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Ropsten"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://ropsten.etherscan.io/address/0xcfcc81c508a8025879a27257cc0f699f9f2016ab"},"0xcfcc81c508a8025879a27257cc0f699f9f2016ab"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Rinkeby"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://rinkeby.etherscan.io/address/0xcfcc81c508a8025879a27257cc0f699f9f2016ab"},"0xcfcc81c508a8025879a27257cc0f699f9f2016ab"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Goerli"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://goerli.etherscan.io/address/0xcfcc81c508a8025879a27257cc0f699f9f2016ab"},"0xcfcc81c508a8025879a27257cc0f699f9f2016ab"))),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"center"},"ETH Testnet Kovan"),(0,o.kt)("td",{parentName:"tr",align:"center"},(0,o.kt)("a",{parentName:"td",href:"https://kovan.etherscan.io/address/0xcfcc81c508a8025879a27257cc0f699f9f2016ab"},"0xcfcc81c508a8025879a27257cc0f699f9f2016ab"))))),(0,o.kt)("h3",{id:"fesw-token-deployments-parameters"},(0,o.kt)("span",{className:"title"}," FESW Token Deployments Parameters ")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"}," constructor( address account, address minterBurner","_",", uint mintingAllowedAfter","_"," ) "))),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:"left"},"Parameters"),(0,o.kt)("th",{parentName:"tr",align:"left"},"Value"),(0,o.kt)("th",{parentName:"tr",align:"left"},"information"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"account"),(0,o.kt)("td",{parentName:"tr",align:"left"},"0xdc7ef6b5d1a15768c0520e54e7414e1e0297e141"),(0,o.kt)("td",{parentName:"tr",align:"left"},"This is the address receiving all the initially minted FESW tokens. FeSwap deployment address is used as this address. Some times later, all the FeSwap tokens will be distributed to various vesting contract according to the ",(0,o.kt)("a",{parentName:"td",href:"../FeSwap/governance"},"FeSwap governance")," rules.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"minterBurner","_"),(0,o.kt)("td",{parentName:"tr",align:"left"},"0xdc7ef6b5d1a15768c0520e54e7414e1e0297e141"),(0,o.kt)("td",{parentName:"tr",align:"left"},"This address controls the FESW minting and burning. FeSwap deployment address is also used at this time. Later it will be shifted to TimeLock contact, which is operated by FeSwap Governance contract that can enforce FESW minting and burning under the control of community proposal and voting.")),(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:"left"},"mintingAllowedAfter","_"),(0,o.kt)("td",{parentName:"tr",align:"left"},"0x6a6d6ed0"),(0,o.kt)("td",{parentName:"tr",align:"left"},"This is the timestamp of the time when FESW minting is allowed. ",(0,o.kt)("br",null),"0x6a6d6ed0 means 2026-08-01 11:58:08")))),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"** Parameters on ETH Chain ")),(0,o.kt)("h3",{id:"fesw-token-contract-code"},(0,o.kt)("span",{className:"title"}," FESW Token Contract Code ")),(0,o.kt)("p",null,"FESW token code is open-sourced at ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/FeSwap/Governance/blob/main/contracts/Feswap.sol"},"Github FeSwapCore Project")," "),(0,o.kt)("p",null,"Following is the code deployed:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sol",metastring:'title="Feswap.sol"',title:'"Feswap.sol"'},'// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.7.0;\npragma experimental ABIEncoderV2;\n\nimport "./utils/SafeMath.sol";\n\ncontract Fesw {\n    /// @notice EIP-20 token name for this token\n    string public constant name = "FeSwap DAO";\n\n    /// @notice EIP-20 token symbol for this token\n    string public constant symbol = "FESW";\n\n    /// @notice EIP-20 token decimals for this token\n    uint8 public constant decimals = 18;\n\n    /// @notice Total number of tokens in circulation\n    uint public totalSupply = 1_000_000_000e18;     // 1 billion FESW\n\n    /// @notice Address which may mint and burn FESW tokens\n    address public minterBurner;\n\n    /// @notice The timestamp after which minting may occur\n    uint public mintingAllowedAfter;\n\n    /// @notice Minimum time between mints\n    uint32 public constant minimumTimeBetweenMints = 1 days * 365;\n\n    /// @notice Cap that can be minted at each mint after 5 years\n    uint public mintCap = 10_000_000e18;      // 10 million FESW\n\n    // @notice Allowance amounts on behalf of others\n    // Documentation tag @notice not valid for non-public state variables\n    mapping (address => mapping (address => uint96)) internal allowances;\n\n    // @notice Official record of token balances for each account\n    mapping (address => uint96) internal balances;\n\n    /// @notice A record of each accounts delegate\n    mapping (address => address) public delegates;\n\n    /// @notice A checkpoint for marking number of votes from a given block\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint96 votes;\n    }\n\n    /// @notice A record of votes checkpoints for each account, by index\n    mapping (address => mapping (uint32 => Checkpoint)) public checkpoints;\n\n    /// @notice The number of checkpoints for each account\n    mapping (address => uint32) public numCheckpoints;\n\n    /// @notice The EIP-712 typehash for the contract\'s domain\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256("EIP712Domain(string name,uint256 chainId,address verifyingContract)");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256("Delegation(address delegatee,uint256 nonce,uint256 expiry)");\n\n    /// @notice The EIP-712 typehash for the permit struct used by the contract\n    bytes32 public constant PERMIT_TYPEHASH = keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");\n\n    /// @notice A record of states for signing / validating signatures\n    mapping (address => uint) public nonces;\n\n    /// @notice An event thats emitted when the minterBurner address is changed\n    event MinterBurnerChanged(address minterBurner, address newMinterBurner);\n\n    /// @notice An event thats emitted when an account changes its delegate\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /// @notice An event thats emitted when a delegate account\'s vote balance changes\n    event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n    /// @notice The standard EIP-20 transfer event\n    event Transfer(address indexed from, address indexed to, uint256 amount);\n\n    /// @notice The standard EIP-20 approval event\n    event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n    /**\n     * @notice Construct a new FESW token\n     * @param account The initial account to grant all the tokens\n     * @param minterBurner_ The account with minting/burning ability\n     * @param mintingAllowedAfter_ The timestamp after which minting may occur\n     */\n    constructor(address account, address minterBurner_, uint mintingAllowedAfter_) {\n        require(mintingAllowedAfter_ >= block.timestamp, "FESW::constructor: minting can only begin after deployment");\n\n        balances[account] = uint96(totalSupply);\n        emit Transfer(address(0), account, totalSupply);\n        minterBurner = minterBurner_;\n        emit MinterBurnerChanged(address(0), minterBurner);\n        mintingAllowedAfter = mintingAllowedAfter_;\n    }\n\n    /**\n     * @notice Change the minter/burner address\n     * @param minterBurner_ The address of the new minter/burner\n     */\n    function setMinterBurner(address minterBurner_) external {\n        require(msg.sender == minterBurner, "FESW::setMinter: only the minter can change the minter address");\n        emit MinterBurnerChanged(minterBurner, minterBurner_);\n        minterBurner = minterBurner_;\n    }\n\n    /**\n     * @notice Mint new tokens\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to be minted\n     */\n    function mint(address dst, uint rawAmount) external {\n        require(msg.sender == minterBurner, "FESW::mint: only the minter can mint");\n        require(block.timestamp >= mintingAllowedAfter, "FESW::mint: minting not allowed yet");\n        require(dst != address(0), "FESW::mint: cannot transfer to the zero address");\n        //maximum 8 times minting\n        require(mintCap >= 50_000e18, "FESW::mint: minting not allowed any more");   \n\n        // record the mint\n        mintingAllowedAfter = SafeMath.add(block.timestamp, minimumTimeBetweenMints);\n\n        // mint the amount\n        uint96 amount = safe96(rawAmount, "FESW::mint: amount exceeds 96 bits");\n        require(amount <= mintCap, "FESW::mint: exceeded mint cap");\n        mintCap = mintCap / 2;\n        totalSupply = safe96(SafeMath.add(totalSupply, amount), "FESW::mint: totalSupply exceeds 96 bits");\n\n        // transfer the amount to the recipient\n        balances[dst] = add96(balances[dst], amount, "FESW::mint: transfer amount overflows");\n        emit Transfer(address(0), dst, amount);\n\n        // move delegates\n        _moveDelegates(address(0), delegates[dst], amount);\n    }\n\n    /**\n     * @notice Burn some tokens\n     */\n    function burn() external {\n        require(msg.sender == minterBurner, "FESW::burn: Only the burner can burn");\n\n        // burn the amount\n        uint96 amount = balances[minterBurner];\n        require(amount != 0, "FESW::burn: No FESW token to burn");\n\n        balances[minterBurner] = 0;\n        totalSupply = SafeMath.sub(totalSupply, amount);\n        emit Transfer(minterBurner, address(0), amount);\n\n        // move delegates\n        _moveDelegates(delegates[minterBurner], address(0), amount);\n    }\n\n    /**\n     * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n    function allowance(address account, address spender) external view returns (uint) {\n        return allowances[account][spender];\n    }\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint rawAmount) external returns (bool) {\n        uint96 amount;\n        if (rawAmount == uint(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, "FESW::approve: amount exceeds 96 bits");\n        }\n\n        allowances[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    /**\n     * @notice Triggers an approval from owner to spends\n     * @param owner The address to approve from\n     * @param spender The address to be approved\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @param deadline The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function permit(address owner, address spender, uint rawAmount, uint deadline, uint8 v, bytes32 r, bytes32 s) external {\n        uint96 amount;\n        if (rawAmount == uint(-1)) {\n            amount = uint96(-1);\n        } else {\n            amount = safe96(rawAmount, "FESW::permit: amount exceeds 96 bits");\n        }\n\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, rawAmount, nonces[owner]++, deadline));\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), "FESW::permit: invalid signature");\n        require(signatory == owner, "FESW::permit: unauthorized");\n        require(block.timestamp <= deadline, "FESW::permit: signature expired");\n\n        allowances[owner][spender] = amount;\n\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n    function balanceOf(address account) external view returns (uint) {\n        return balances[account];\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint rawAmount) external returns (bool) {\n        uint96 amount = safe96(rawAmount, "FESW::transfer: amount exceeds 96 bits");\n        _transferTokens(msg.sender, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n        address spender = msg.sender;\n        uint96 spenderAllowance = allowances[src][spender];\n        uint96 amount = safe96(rawAmount, "FESW::approve: amount exceeds 96 bits");\n\n        if (spender != src && spenderAllowance != uint96(-1)) {\n            uint96 newAllowance = sub96(spenderAllowance, amount, "FESW::transferFrom: transfer amount exceeds spender allowance");\n            allowances[src][spender] = newAllowance;\n\n            emit Approval(src, spender, newAllowance);\n        }\n        \n        _transferTokens(src, dst, amount);\n        return true;\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function delegate(address delegatee) public {\n        return _delegate(msg.sender, delegatee);\n    }\n\n    /**\n     * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n    function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n        bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n        bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n        bytes32 digest = keccak256(abi.encodePacked("\\x19\\x01", domainSeparator, structHash));\n        address signatory = ecrecover(digest, v, r, s);\n        require(signatory != address(0), "FESW::delegateBySig: invalid signature");\n        require(nonce == nonces[signatory]++, "FESW::delegateBySig: invalid nonce");\n        require(block.timestamp <= expiry, "FESW::delegateBySig: signature expired");\n        return _delegate(signatory, delegatee);\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function getCurrentVotes(address account) external view returns (uint96) {\n        uint32 nCheckpoints = numCheckpoints[account];\n        return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n    }\n\n    /**\n     * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n    function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n        require(blockNumber < block.number, "FESW::getPriorVotes: not yet determined");\n\n        uint32 nCheckpoints = numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n\n        // First check most recent balance\n        if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n            return checkpoints[account][nCheckpoints - 1].votes;\n        }\n\n        // Next check implicit zero balance\n        if (checkpoints[account][0].fromBlock > blockNumber) {\n            return 0;\n        }\n\n        uint32 lower = 0;\n        uint32 upper = nCheckpoints - 1;\n        while (upper > lower) {\n            uint32 center = upper - (upper - lower) / 2; // ceil, avoiding overflow\n            Checkpoint memory cp = checkpoints[account][center];\n            if (cp.fromBlock == blockNumber) {\n                return cp.votes;\n            } else if (cp.fromBlock < blockNumber) {\n                lower = center;\n            } else {\n                upper = center - 1;\n            }\n        }\n        return checkpoints[account][lower].votes;\n    }\n\n    function _delegate(address delegator, address delegatee) internal {\n        address currentDelegate = delegates[delegator];\n        uint96 delegatorBalance = balances[delegator];\n        delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _transferTokens(address src, address dst, uint96 amount) internal {\n        require(src != address(0), "FESW::_transferTokens: cannot transfer from the zero address");\n        require(dst != address(0), "FESW::_transferTokens: cannot transfer to the zero address");\n\n        balances[src] = sub96(balances[src], amount, "FESW::_transferTokens: transfer amount exceeds balance");\n        balances[dst] = add96(balances[dst], amount, "FESW::_transferTokens: transfer amount overflows");\n        emit Transfer(src, dst, amount);\n\n        _moveDelegates(delegates[src], delegates[dst], amount);\n    }\n\n    function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n        if (srcRep != dstRep && amount > 0) {\n            if (srcRep != address(0)) {\n                uint32 srcRepNum = numCheckpoints[srcRep];\n                uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n                uint96 srcRepNew = sub96(srcRepOld, amount, "FESW::_moveVotes: vote amount underflows");\n                _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n            }\n\n            if (dstRep != address(0)) {\n                uint32 dstRepNum = numCheckpoints[dstRep];\n                uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n                uint96 dstRepNew = add96(dstRepOld, amount, "FESW::_moveVotes: vote amount overflows");\n                _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n            }\n        }\n    }\n\n    function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n      uint32 blockNumber = safe32(block.number, "FESW::_writeCheckpoint: block number exceeds 32 bits");\n\n      if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n          checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n      } else {\n          checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n          numCheckpoints[delegatee] = nCheckpoints + 1;\n      }\n\n      emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n    }\n\n    function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n        require(n < 2**32, errorMessage);\n        return uint32(n);\n    }\n\n    function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n        require(n < 2**96, errorMessage);\n        return uint96(n);\n    }\n\n    function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        uint96 c = a + b;\n        require(c >= a, errorMessage);\n        return c;\n    }\n\n    function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n        require(b <= a, errorMessage);\n        return a - b;\n    }\n\n    function getChainId() internal pure returns (uint) {\n        uint256 chainId;\n        assembly { chainId := chainid() }\n        return chainId;\n    }\n}\n')))}l.isMDXComponent=!0}}]);